# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: waymo_open_dataset/protos/keypoint.proto, waymo_open_dataset/protos/keypoints_metrics.proto, waymo_open_dataset/protos/keypoints_submission.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "KeypointType",
    "CameraKeypoint",
    "CameraKeypoints",
    "Keypoint2D",
    "Keypoint3D",
    "KeypointGroupMetric",
    "KeypointMetrics",
    "KeypointThresholdMetric",
    "KeypointVisibility",
    "LaserKeypoint",
    "LaserKeypoints",
    "PoseEstimation",
    "PoseEstimationKey",
    "PoseEstimationSubmission",
)

from dataclasses import dataclass

import betterproto2

from ....message_pool import default_message_pool

betterproto2.check_compiler_version("0.3.1")


class KeypointType(betterproto2.Enum):
    """
    All types of keypoints except (NOSE and HEAD_CENTER) are defined as the 3D
    location where corresponing bones meet - inside the body.
    We use person-centric coordinates in this task. For example, the personâ€™s
    right shoulder will be located on the left side of the image for frontal
    views and on the right side of the image for back views. Similarly for the
    other body joints.
    """

    @staticmethod
    def _serialized_pb():
        return b"\n\x0cKeypointType\x12\x1b\n\x19KEYPOINT_TYPE_UNSPECIFIED\x12\x16\n\x12KEYPOINT_TYPE_NOSE\x10\x01\x12\x1f\n\x1bKEYPOINT_TYPE_LEFT_SHOULDER\x10\x05\x12\x1c\n\x18KEYPOINT_TYPE_LEFT_ELBOW\x10\x06\x12\x1c\n\x18KEYPOINT_TYPE_LEFT_WRIST\x10\x07\x12\x1a\n\x16KEYPOINT_TYPE_LEFT_HIP\x10\x08\x12\x1b\n\x17KEYPOINT_TYPE_LEFT_KNEE\x10\t\x12\x1c\n\x18KEYPOINT_TYPE_LEFT_ANKLE\x10\n\x12 \n\x1cKEYPOINT_TYPE_RIGHT_SHOULDER\x10\r\x12\x1d\n\x19KEYPOINT_TYPE_RIGHT_ELBOW\x10\x0e\x12\x1d\n\x19KEYPOINT_TYPE_RIGHT_WRIST\x10\x0f\x12\x1b\n\x17KEYPOINT_TYPE_RIGHT_HIP\x10\x10\x12\x1c\n\x18KEYPOINT_TYPE_RIGHT_KNEE\x10\x11\x12\x1d\n\x19KEYPOINT_TYPE_RIGHT_ANKLE\x10\x12\x12\x1a\n\x16KEYPOINT_TYPE_FOREHEAD\x10\x13\x12\x1d\n\x19KEYPOINT_TYPE_HEAD_CENTER\x10\x14"

    UNSPECIFIED = 0

    NOSE = 1
    """
    Tip of nose.
    """

    LEFT_SHOULDER = 5

    LEFT_ELBOW = 6

    LEFT_WRIST = 7

    LEFT_HIP = 8

    LEFT_KNEE = 9

    LEFT_ANKLE = 10

    RIGHT_SHOULDER = 13

    RIGHT_ELBOW = 14

    RIGHT_WRIST = 15

    RIGHT_HIP = 16

    RIGHT_KNEE = 17

    RIGHT_ANKLE = 18

    FOREHEAD = 19
    """
    Center of the forehead area.
    """

    HEAD_CENTER = 20
    """
    A point in the center of head - a point in the middle between two ears.
    The nose and head center together create an imaginary line in the direction
    that the person is looking (i.e. head orientation).
    """


@dataclass(eq=False, repr=False)
class CameraKeypoint(betterproto2.Message):
    """
    A 2D keypoint on a specific camera.
    """

    @staticmethod
    def _serialized_pb():
        return b"\n\x0eCameraKeypoint\x12>\n\x04type\x18\x01 \x01(\x0e2*.waymo.open_dataset.keypoints.KeypointTypeR\x04type\x12I\n\x0bkeypoint_2d\x18\x02 \x01(\x0b2(.waymo.open_dataset.keypoints.Keypoint2dR\nkeypoint2d\x12I\n\x0bkeypoint_3d\x18\x03 \x01(\x0b2(.waymo.open_dataset.keypoints.Keypoint3dR\nkeypoint3d"

    type: "KeypointType" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: KeypointType(0)
    )

    keypoint_2d: "Keypoint2D | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Camera coordinates.
    """

    keypoint_3d: "Keypoint3D | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    3D keypoint in camera coordinate frame.
    """


default_message_pool.register_message(
    "waymo.open_dataset.keypoints", "CameraKeypoint", CameraKeypoint
)


@dataclass(eq=False, repr=False)
class CameraKeypoints(betterproto2.Message):
    """
    All 2D keypoints for a camera label (object).
    """

    @staticmethod
    def _serialized_pb():
        return b"\n\x0fCameraKeypoints\x12H\n\x08keypoint\x18\x01 \x03(\x0b2,.waymo.open_dataset.keypoints.CameraKeypointR\x08keypoint"

    keypoint: "list[CameraKeypoint]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "waymo.open_dataset.keypoints", "CameraKeypoints", CameraKeypoints
)


@dataclass(eq=False, repr=False)
class Keypoint2D(betterproto2.Message):
    """
    Keypoint relative to a specific camera image.
    """

    @staticmethod
    def _serialized_pb():
        return b"\n\nKeypoint2d\x12=\n\x0blocation_px\x18\x01 \x01(\x0b2\x1c.waymo.open_dataset.Vector2dR\nlocationPx\x12P\n\nvisibility\x18\x02 \x01(\x0b20.waymo.open_dataset.keypoints.KeypointVisibilityR\nvisibility*\t\x08\xe8\x07\x10\x80\x80\x80\x80\x02"

    location_px: "__open_dataset__.Vector2D | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Camera image coordinates (in pixels, x=0, y=0 is top-left pixel).
    """

    visibility: "KeypointVisibility | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Visibility attributes determined based on camera image only.
    """


default_message_pool.register_message(
    "waymo.open_dataset.keypoints", "Keypoint2d", Keypoint2D
)


@dataclass(eq=False, repr=False)
class Keypoint3D(betterproto2.Message):
    @staticmethod
    def _serialized_pb():
        return b"\n\nKeypoint3d\x12;\n\nlocation_m\x18\x01 \x01(\x0b2\x1c.waymo.open_dataset.Vector3dR\tlocationM\x12P\n\nvisibility\x18\x02 \x01(\x0b20.waymo.open_dataset.keypoints.KeypointVisibilityR\nvisibility*\t\x08\xe8\x07\x10\x80\x80\x80\x80\x02"

    location_m: "__open_dataset__.Vector3D | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    A 3D coordinate in vehicle or camera frame (depending which message it is
    part of - LaserKeypoint or CameraKeypoint).
    """

    visibility: "KeypointVisibility | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Visibility attributes determined based on all available data (camera image
    and or lidar).
    """


default_message_pool.register_message(
    "waymo.open_dataset.keypoints", "Keypoint3d", Keypoint3D
)


@dataclass(eq=False, repr=False)
class KeypointGroupMetric(betterproto2.Message):
    @staticmethod
    def _serialized_pb():
        return b"\n\x13KeypointGroupMetric\x12\x14\n\x05value\x18\x01 \x01(\x02R\x05value\x12\x1d\n\ngroup_name\x18\x02 \x01(\tR\tgroupName"

    value: "float" = betterproto2.field(1, betterproto2.TYPE_FLOAT)
    """
    Numeric value of the metric.
    """

    group_name: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)
    """
    Group of keypoins used for evaluation of the metric.
    Refer to metrics/python/keypoint_metrics.py for the list of canonical
    groups of keypoints.
    """


default_message_pool.register_message(
    "waymo.open_dataset.keypoints", "KeypointGroupMetric", KeypointGroupMetric
)


@dataclass(eq=False, repr=False)
class KeypointMetrics(betterproto2.Message):
    @staticmethod
    def _serialized_pb():
        return b"\n\x0fKeypointMetrics\x12G\n\x05mpjpe\x18\x01 \x03(\x0b21.waymo.open_dataset.keypoints.KeypointGroupMetricR\x05mpjpe\x12G\n\x03oks\x18\x02 \x03(\x0b25.waymo.open_dataset.keypoints.KeypointThresholdMetricR\x03oks\x12G\n\x03pck\x18\x03 \x03(\x0b25.waymo.open_dataset.keypoints.KeypointThresholdMetricR\x03pck\x12C\n\x03pem\x18\x04 \x03(\x0b21.waymo.open_dataset.keypoints.KeypointGroupMetricR\x03pem\x12O\n\tprecision\x18\x05 \x03(\x0b21.waymo.open_dataset.keypoints.KeypointGroupMetricR\tprecision\x12I\n\x06recall\x18\x06 \x03(\x0b21.waymo.open_dataset.keypoints.KeypointGroupMetricR\x06recall\x12H\n\x06oks_ap\x18\x07 \x03(\x0b21.waymo.open_dataset.keypoints.KeypointGroupMetricR\x05oksAp"

    mpjpe: "list[KeypointGroupMetric]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Mean Per Joint Position Error.
    """

    oks: "list[KeypointThresholdMetric]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Precision at different thresholds for Object Keypoint Similarity
    (aka OKS) values. We use scales `DEFAULT_PER_TYPE_SCALES` from
    metrics/python/keypoint_metrics.py to compute OKS for different keypoint
    types.
    """

    pck: "list[KeypointThresholdMetric]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Percentage of Correct Keypoints.
    """

    pem: "list[KeypointGroupMetric]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Pose Estimation Metric
    """

    precision: "list[KeypointGroupMetric]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Keypoint detection precision
    """

    recall: "list[KeypointGroupMetric]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Keypoint detection recall
    """

    oks_ap: "list[KeypointGroupMetric]" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Average precision computed over all thresholds for Object Keypoint
    Similarity (aka OKS) values.
    """


default_message_pool.register_message(
    "waymo.open_dataset.keypoints", "KeypointMetrics", KeypointMetrics
)


@dataclass(eq=False, repr=False)
class KeypointThresholdMetric(betterproto2.Message):
    @staticmethod
    def _serialized_pb():
        return b"\n\x17KeypointThresholdMetric\x12\x14\n\x05value\x18\x01 \x01(\x02R\x05value\x12\x1d\n\ngroup_name\x18\x02 \x01(\tR\tgroupName\x12\x1c\n\tthreshold\x18\x03 \x01(\x02R\tthreshold"

    value: "float" = betterproto2.field(1, betterproto2.TYPE_FLOAT)
    """
    Numeric value of the metric.
    """

    group_name: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)
    """
    Group of keypoins used for evaluation of the metric.
    Refer to metrics/python/keypoint_metrics.py for the list of canonical
    groups of keypoints.
    """

    threshold: "float" = betterproto2.field(3, betterproto2.TYPE_FLOAT)


default_message_pool.register_message(
    "waymo.open_dataset.keypoints", "KeypointThresholdMetric", KeypointThresholdMetric
)


@dataclass(eq=False, repr=False)
class KeypointVisibility(betterproto2.Message):
    """
    Attributes related to the keypoint's visibility.
    """

    @staticmethod
    def _serialized_pb():
        return b"\n\x12KeypointVisibility\x12\x1f\n\x0bis_occluded\x18\x01 \x01(\x08R\nisOccluded"

    is_occluded: "bool" = betterproto2.field(1, betterproto2.TYPE_BOOL)
    """
    Is true, if the keypoint is occluded by any object, a body part or its
    location can be determined only with large uncertainty.
    Is false if the keypoint is clearly visible.
    """


default_message_pool.register_message(
    "waymo.open_dataset.keypoints", "KeypointVisibility", KeypointVisibility
)


@dataclass(eq=False, repr=False)
class LaserKeypoint(betterproto2.Message):
    """
    A 3D keypoint.
    """

    @staticmethod
    def _serialized_pb():
        return b"\n\rLaserKeypoint\x12>\n\x04type\x18\x01 \x01(\x0e2*.waymo.open_dataset.keypoints.KeypointTypeR\x04type\x12I\n\x0bkeypoint_3d\x18\x02 \x01(\x0b2(.waymo.open_dataset.keypoints.Keypoint3dR\nkeypoint3d"

    type: "KeypointType" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: KeypointType(0)
    )

    keypoint_3d: "Keypoint3D | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    3D keypoint in vehicle coordinate frame.
    """


default_message_pool.register_message(
    "waymo.open_dataset.keypoints", "LaserKeypoint", LaserKeypoint
)


@dataclass(eq=False, repr=False)
class LaserKeypoints(betterproto2.Message):
    """
    All 3D keypoints for a laser label (object).
    """

    @staticmethod
    def _serialized_pb():
        return b"\n\x0eLaserKeypoints\x12G\n\x08keypoint\x18\x01 \x03(\x0b2+.waymo.open_dataset.keypoints.LaserKeypointR\x08keypoint"

    keypoint: "list[LaserKeypoint]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "waymo.open_dataset.keypoints", "LaserKeypoints", LaserKeypoints
)


@dataclass(eq=False, repr=False)
class PoseEstimation(betterproto2.Message):
    @staticmethod
    def _serialized_pb():
        return b"\n\x0ePoseEstimation\x12B\n\x03key\x18\x01 \x01(\x0b20.waymo.open_dataset.keypoints.PoseEstimation.KeyR\x03key\x12U\n\x0flaser_keypoints\x18\x02 \x01(\x0b2,.waymo.open_dataset.keypoints.LaserKeypointsR\x0elaserKeypoints\x12+\n\x03box\x18\x03 \x01(\x0b2\x19.waymo.open_dataset.Box3dR\x03box\x1am\n\x12PoseEstimation.Key\x12!\n\x0ccontext_name\x18\x01 \x01(\tR\x0bcontextName\x124\n\x16frame_timestamp_micros\x18\x02 \x01(\x03R\x14frameTimestampMicros"

    key: "PoseEstimationKey | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    laser_keypoints: "LaserKeypoints | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )

    box: "__open_dataset__.Box3D | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "waymo.open_dataset.keypoints", "PoseEstimation", PoseEstimation
)


@dataclass(eq=False, repr=False)
class PoseEstimationKey(betterproto2.Message):
    """
    Fields to identify the predicted keypoints.
    """

    @staticmethod
    def _serialized_pb():
        return b"\n\x12PoseEstimation.Key\x12!\n\x0ccontext_name\x18\x01 \x01(\tR\x0bcontextName\x124\n\x16frame_timestamp_micros\x18\x02 \x01(\x03R\x14frameTimestampMicros"

    context_name: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    Same as Frame.context.name.
    """

    frame_timestamp_micros: "int" = betterproto2.field(2, betterproto2.TYPE_INT64)
    """
    Same as Frame.timestamp_micros.
    """


default_message_pool.register_message(
    "waymo.open_dataset.keypoints", "PoseEstimation.Key", PoseEstimationKey
)


@dataclass(eq=False, repr=False)
class PoseEstimationSubmission(betterproto2.Message):
    @staticmethod
    def _serialized_pb():
        return b"\n\x18PoseEstimationSubmission\x12!\n\x0caccount_name\x18\x01 \x01(\tR\x0baccountName\x12,\n\x12unique_method_name\x18\x02 \x01(\tR\x10uniqueMethodName\x12\x18\n\x07authors\x18\x03 \x03(\tR\x07authors\x12 \n\x0baffiliation\x18\x04 \x01(\tR\x0baffiliation\x12 \n\x0bdescription\x18\x05 \x01(\tR\x0bdescription\x12\x1f\n\x0bmethod_link\x18\x06 \x01(\tR\nmethodLink\x12W\n\x10pose_estimations\x18\x07 \x03(\x0b2,.waymo.open_dataset.keypoints.PoseEstimationR\x0fposeEstimations"

    account_name: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    This must be set as the full email used to register at waymo.com/open.
    """

    unique_method_name: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)
    """
    This name needs to be short, descriptive and unique. Only the latest result
    of the method from a user will show up on the leaderboard.
    """

    authors: "list[str]" = betterproto2.field(
        3, betterproto2.TYPE_STRING, repeated=True
    )
    """
    Author information.
    """

    affiliation: "str" = betterproto2.field(4, betterproto2.TYPE_STRING)

    description: "str" = betterproto2.field(5, betterproto2.TYPE_STRING)
    """
    A brief description of the method.
    """

    method_link: "str" = betterproto2.field(6, betterproto2.TYPE_STRING)
    """
    Link to paper or other link that describes the method.
    """

    pose_estimations: "list[PoseEstimation]" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Estimated pose for all objects in the validation or test subset of the
    dataset.
    """


default_message_pool.register_message(
    "waymo.open_dataset.keypoints", "PoseEstimationSubmission", PoseEstimationSubmission
)


from ... import open_dataset as __open_dataset__
